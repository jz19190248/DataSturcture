# 交换排序综合应用题

[TOC]



## 1 非递归实现快速排

    实现见代码，要点是注意push和pop的顺序，stack和queue的顺序敲好相反，但是变动不大；

```c++
//核心代码：
#include <iostream>
#include <stack>
#include <vector>
#include <queue>
using namespace std;

#define ElemType int

int Parttion(ElemType A[], int low, int high)
{
    ElemType point = A[low];
    while (low < high)
    {
        while (low < high && A[high] > point)
            high--;
        A[low] = A[high];
        while (low < high && A[low] < point)
            low++;
        A[high] = A[low];
    }
    A[low] = point;
    return low;
}

void quickSortByStack(ElemType A[], int low, int high)
{
    if (low < high)
    {
        stack<int> mystack;
        mystack.push(low);
        mystack.push(high);
        while (!mystack.empty())
        {
            int r = mystack.top();
            mystack.pop();
            int l = mystack.top();
            mystack.pop();
            if (l < r)
            {
                int point = Parttion(A, l, r);
                mystack.push(l);
                mystack.push(point - 1);
                mystack.push(point + 1);
                mystack.push(r);
            }
        }
    }
    else
        return;
}

void quickSortByQueue(ElemType A[], int low, int high)
{
    if (low >= high)
        return;
    queue<int> qu;
    qu.push(low);
    qu.push(high);
    while (!qu.empty())
    {
        int l = qu.front();
        qu.pop();
        int r = qu.front();
        qu.pop();
        if (l < r)
        {
            int point = Parttion(A, l, r);
            qu.push(l);
            qu.push(point - 1);
            qu.push(point + 1);
            qu.push(r);
        }
    }
}

int main()
{
    int arr1[] = {65, 97, 76, 38, 27, 49, 34};
    quickSortByStack(arr1, 0, 6);
    cout << "quickByStack:";
    for (int i = 0; i < 7; i++)
    {
        cout << arr1[i] << "  " << endl;
    }

    int arr2[] = {65, 25, 76, 38, 27, 49, 34};
    quickSortByQueue(arr2, 0, 6);
    cout << "quickByQueue:";
    for (int i = 0; i < 7; i++)
    {
        cout << arr2[i] << "  " << endl;
    }
    return 0;
}

```
## 2双向冒泡排序
```C++
//双向起泡排序
#include <iostream>
#define ElemType int
using namespace std;
void swap(ElemType &a, ElemType &b)
{
    ElemType temp = a;
    a = b;
    b = temp;
}
void BubbleSort(ElemType A[], int n)
{
    int low = 0, high = n - 1;
    bool flag = true;
    while (low < high && flag)
    {
        flag = false;
        for (int i = low; i < high; i++)
        {
            if (A[i] > A[i + 1])
            {
                swap(A[i], A[i + 1]);
                flag = true;
            }
        }
        high--;
        for (int i = high; i > low; i--)
        {
            if (A[i] < A[i - 1])
            {
                flag = false;
                swap(A[i], A[i - 1]);
            }
        }
        low++;
    }
}

int main()
{
    int arr[] = {65, 97, 76, 38, 27, 49, 34};
    BubbleSort(arr, 7);
    cout << "BubbleSort:" << endl;
    for (int i = 0; i < 7; i++)
    {
        cout << arr[i] << "  " << endl;
    }
    return 0;
}
```
## 3 移动奇偶数
>双指针|Parttion变形
```C++
    #include <iostream>
using namespace std;
#define ElemType int
void selectOdevity(ElemType A[], int n)
{
    int low = 0;
    int high = n - 1;
    ElemType temp = A[low];
    while (low < high)
    {
        while (low < high && (A[high] % 2 == 0))
            high--;
        A[low] = A[high];
        while (low < high && (A[low] % 2 == 1))
            low++;
        A[high] = A[low];
    }
    A[low] = temp;
}
int main(int argv, char **args)
{
    int arr[] = {65, 97, 76, 38, 27, 49, 34};
    selectOdevity(arr, 7);
    cout << "After select odevity:" << endl;
    for (int i = 0; i < 7; i++)
    {
        cout << arr[i] << "  " << endl;
    }
    return 0;
}
```

## 4 基于随机基准轴的划分

>每次只需要将需要的基准轴准备好，然后与咯哇交换位置，无论是随机的，还是取三个数的中间值，都可以采用这样的策略，而后与第一个数作为枢轴无异

```C++
#include <iostream>
#include <cstdlib>

using namespace std;
#define ElemType int

int Parttion(ElemType A[], int low, int high)
{
    int rand_index = low + rand() % (high - low + 1);
    ElemType temp = A[low];
    A[low] = A[rand_index];
    A[rand_index] = temp;

    ElemType point = A[low];

    while (low < high)
    {
        while (low < high && A[high] > point)
            high--;
        A[low] = A[high];
        while (low < high && A[low] < point)
            low++;
        A[high] = A[low];
    }
    A[low] = point;
    return low;
}

void quickSort(ElemType A[], int low, int high)
{
    if (low < high)
    {
        ElemType point = Parttion(A, low, high);
        quickSort(A, low, point - 1);
        quickSort(A, point + 1, high);
    }
}

int main(int argv, char **args)
{
    int arr[] = {65, 21, 76, 38, 27, 49, 34};
    quickSort(arr, 0, 6);
    cout << "quickSort:" << endl;
    for (int i = 0; i < 7; i++)
    {
        cout << arr[i] << "  " << endl;
    }
    return 0;
}
```

